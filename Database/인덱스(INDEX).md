# ⭐️ 인덱스(INDEX)

### 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

마치 **두꺼운 책의 목차**같은 존재이다.

B+ Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상시킨다.

### 파일 구성

테이블을 CREATE하면, 3가지 파일이 생성이된다.

- FRM: 테이블 구조 저장 파일
- MYD: 실제 데이터 파일
- MYI: Index 정보 파일 (Index 사용 시 생성)

사용자가 쿼리를 통해 Index를 사용하는 칼럼을 검색하면, 이때 MYI 파일의 내용을 활용한다.

### 단점

- .mdb 파일 크기가 증가한다. → 인덱스라는 추가 데이터 구조를 저장해야 하므로
- **한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.**
    
    인덱스를 생성하면 한 페이지(해당 인덱스 페이지)에 대한 접근이 늘어나고, 해당 페이지에 락이 발생할 가능성이 높다. → 여러 트랜잭션이 해당 페이지에 동시 접근할 때 문제가 생기고 병행성이 줄어든다.
    
- **인덱스된 Field에서 Data를 업데이트 하거나, Record를 추가 또는 삭제 시에는 성능이 떨어진다.**
- 데이터 변경 작업이 자주 일어나면 Index를 재작성해야 하므로 성능에 영향을 미친다.
    
    원본 데이터가 변경되면 인덱스도 함께 수정되어야함. 데이터 변경 작업이 더많은 오버헤드와 시간을 필요로 할 수 있다.
    
---

### 상황 분석

**⭐️GOOD**

1. where절에서 자주 사용되는 Column
2. 외래키가 사용되는 Column
3. Join에 자주 사용되는 Column

**🔥BAD**

1. data 중복도가 높은 Column
2. 삽입수정삭제(DML)이 자주 일어나는 Column
3. 데이터의 양이 적으면 적을수록 효율을 내기 힘듦

> 인덱스는 테이블의 **전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우**에만 **효율적**이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.!
예를 들면 **100개의 데이터**가 있는 테이블과 **100만 개의 데이터**가 들어 있는 테이블이 있다고 하자. **100만 개의 데이터**가 들어있는 테이블이라면 풀 스캔보다는 인덱스 스캔이 유리하겠지만, **100개의 데이터**가 들어있는 테이블은 굳이 인덱스 스캔 없이 풀 스캔이 빠를 것이다.


**⭐️DML이 일어났을 때 상황**

1. INSERT

기존 Block에 여유가 없을 때, 새로운 DATA가 입력되면 새로운 Block을 할당 받은 후, Key를 옮기는 작업이 수행된다. 
→ Index split 작업 동안, 해당 Block의 Key값에 대해 DML이 블로킹 된다. (인덱스 스플릿이 끝날 때까지 기다려야 돼서 대기 이벤트가 발생하게 됨) .
→ 인덱스 스플릿이 발생하면 Block의 물리적인 구조가 변경될 수 있다. 이때 Block의 논리적인 순서와 물리적인 순서가 달라져 인덱스 조각화가 일어날 수 있다.


> 💡 Index Split: 주로 B-tree, B+tree와 같은 트리 기반 인덱스 구조에서, 데이터 삽입,삭제 발생시 인덱스 구조를 유지하기 위해 트리 형태를 조정할때 발생한다.
인덱스 노드가 너무 커져서 분할이 필요할 때 발생하는데, 새로운 데이터가 삽입되어 인덱스 노드가 가득 차거나, 특정 조건을 충족할 때 스플릿이 발생한다.


2.  DELETE
- Table에서 data가 삭제되는 경우 : 데이터가 지워지고 다른 데이터가 그 공간을 사용
- Index에서 data가 삭제되는 경우: 실제로 데이터가 지워지지 않고, 삭제된 데이터를 가르키는 인덱스 항목에 대해 특별한 플래그를 설정하여 **사용 안됨**을 표시한다.

**→ Table 데이터 수와 Index데이터 수가 다를 수도 있다.**

3.  UPDATE
- Table에서 update가 발생하는 경우 Index는 update 할 수 없다.
- Index에서는 Delete가 발생한 후 새로 Insert를 해야한다. → **삭제 후 삽입을 해야해서 2배 작업 소요**

---

### 인덱스 관리 방식

- **B-Tree**
    
    이진 탐색 트리와 유사하지만, 자식 노드를 둘 이상 가질 수 있고 Balanced Tree라는 특징이 있다. → Search 연산에 있어 O(logN)의 시간복잡도
    
    모든 노드들에 대해 값을 저장하고 있고, 포인터 역할을 동반한다.
    
  ![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/060448c2-feb4-47d6-b344-51b238a5b020)

**검색 동작 순서**
1. 인덱스 노드에 접근
2. 인덱스 노드를 검색하여 검색 키와 일치하는 서브트리 선택
3. 선택한 서브트리에서 다시 검색 수행
4. 검색 키와 일치하는 데이터 페이지를 찾으면 검색을 종료
    
B tree의 경우 키 값과 데이터 값이 노드 안에 함께 저장되므로 노드 크기가 크고 구조 유지를 위해 추가적 연산이 필요하다.

---

- **B+Tree**
    
    B-Tree를 개선한 형태의 자료 구조로, **값을 리프노드에만 저장**한다. 리프노드들끼리는 **LinkedList로 연결**되어 있다. → 부등호문 연산에 대해 효과적이다.
    
    리프 노드를 제외한 노드들은 포인터 역할만을 수행한다.
    
![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/b218ee9d-8004-4777-9cfe-0bbfe61fadad)

---

- **HashTable**
    
    해시 함수를 이용해서 값을 인덱스로 변경하여 관리
    
    탐색, 삽입, 삭제 연산에 대해 O(1)의 시간 복잡도를 갖으며 다른 관리 방식에 비해 빠른 성능을 갖는다.
    
    최악의 경우 해시 충돌이 발생하는 것 ! → 탐색 삽입 삭제 연산에 대해 O(N)의 시간 복잡도를 가짐
    

>  💡 저번 시간에 봤던 것처럼, 해시 충돌이 발생하게 되면 체이닝 혹은 개방 주소법을 통해 처리한다. 체이닝을 통해 처리할 경우 링크드리스트를 타고 N번 내려가야되고, 개방주소법을 사용할 경우에도 빈 인덱스를 발견할 때까지 타고 계속 내려가야된다.

    
    해시테이블은 등호(=)연산에 최적화되어있지만, 데이터베이스에서는 부등호(<,>)연산이 자주 사용되므로 실제로 인덱스에서 잘 사용되지 않는다.
