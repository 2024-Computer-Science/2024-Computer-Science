# ⭐️ 정규화 
### 데이터의 중복을 줄이고, 무결성을 향상시키는 것!

가장 큰 목표는 **중복된 데이터를 허용하지 않는 것**이다.

→ 무결성 유지, DB 저장 용량을 효율적으로 관리

### 목적

- **데이터의 중복을 없애면서** 불필요한 데이터를 최소화
- **무결성**을 지키고 **이상 현상 방지**
- 테이블 구성을 논리적이고 직관적으로 할 수 있음
- 데이터베이스 구조 확장이 용이하다.

### 정규형(normal form)

**특정 조건을 만족하는 릴레이션 스키마의 형태**

- 제 1정규형, 제 2정규형, 제 3 정규형, … 등등

### 🌟제 1 정규화(1NF)

테이블 컬럼이 오직 원자값(하나의 값)만을 갖도록 테이블을 분리하는 정규화이다.

- **애트리 뷰트의 도메인이 오직 원자값만을 포함**
- 투플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야함
- 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/b74d6c62-c778-4c55-a708-36a30909b38c)

`Department`라는 테이블이 있고, `Dnumbe`r라는 기본키를 가지고 있을 때, (b)는 제 1 정규형을 만족하지 못한다. `Dnumber` 5의 애트리뷰트 location이 원자값만을 포함하지 않고 3개나 가지고 있기 때문에. → 따라서 (c)와 같이 제 1정규형을 만족하도록 정규화한다.

---

### 🌟제 2 정규화(2NF)

**테이블의 모든 컬럼이 완전 함수적 종속을 만족해야한다.**

테이블에서 기본키가 **복합키**로 묶여있을 때, 두 키 중 하나의 키 만으로 다른 컬럼을 결정지을 수 있으면 안된다.

<aside>
💡 제 2 정규형의 정의 : **릴레이션 스키마 R의 모든 비주요 애트리뷰트들이 기본키에 대해 완전 함수적 종속이면, R은 제2정규형에 속한다.**

</aside>

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/58c93b3c-995e-4b06-b951-643898ff3b55)

a와 같은 릴레이션이 있다고 가정.

함수 종속이 위와 같이 되어있다고 가정을 해보자.  `SSN`과 `Pnumber`가 복합키로 묶여있을 때, `HOURS`는 `SSN`과 `PNUMBER` 두 키로 인해 결정되지만, **`ENAME`은 `SSN`에 의해서만, `Pname`과 `Plocation`은 `Pnumber`에 의해서만 결정된다. 이러면 부분종속이 생기는 거다.**

<aside>
💡 {SSN, PNUMBER} → HOURS 는 SSN→HOURS 와 PNUMBER→ HOURS가 성립하지 않기 때문에, 완전 함수적 종속성이다.
하지만 {SSN, PNUMBER} → ENAME은 SSN → ENAME이 성립하기 때문에 완전 함수적 종속성이 아니고 부분 함수 종속성이다.

</aside>

따라서 완전 함수적 종속이 되도록 그림과 같이 제2정규화를 진행해야한다.

---

### 🌟제 3 정규화(3NF)

**이행적 함수 종속을 없애기 위해 테이블을 분리**한다.

이행 함수적 종속성: A → B, B→C면 A→C가 성립하는 것

<aside>
💡 제 3 정규형의 정의 : **릴레이션 스키마 R이 제2정규형을 만족하고, R의 어떤 비주요 애트리뷰트도 기본키에 대해 이행적으로 종속되지 않으면 R은 제 3정규형을 만족한다.**

</aside>

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/bed5a11a-4101-43af-a0a6-2ed46af6b3c3)

이 테이블의 기본키는 `SSN`이고, `Dnumber`는 `SSN`에 의해 결정되는데,  `Dname`과 `Dmgr_ssn`은 `Dnumber`에 의해 결정되고 있다. → **이행 함수적 종속!**

이를 제거하기 위해 위와 같이 제 3정규화를 통해 테이블을 나누어야 한다.

---

### 🌟BCNF(Boyce-codd Normal Form)

릴레이션 R의 **모든 결정자가 후보키**이면 릴레이션 R은 BCNF에 속한다.

<aside>
💡 후보키: 각 데이터를 **유일하게 식별**할 수 있는 “**최소**한의” 속성 집합

</aside>

제약조건

- 각 과목에 대한 한 학생은 오직 한 교수의 강의만 수강 ( **학번** → 교수 1:1)
- 각 교수는 한 과목만 담당 (**교수** → 과목 1:1)
- 한 과목은 여러 교수가 담당할 수 있음 ( **과목** → 교수 1:N)

결정자는 굵은 글씨

<img width="725" alt="스크린샷 2024-04-30 오후 11 07 38" src="https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/8633b0b2-5251-405f-9a75-3eac9a0bdb4b">

수강 과목은 학번, 과목, 교수 애트리뷰트로 이루어져있고, 후보키는 {학번,과목}, {학번,교수}이다. 

기본키는 {학번,과목}이라고 지정했을 때, **교수는 과목을 결정하지만 후보키가 아니기때문에 이상이 발생**할 수 있다.

1. 삽입이상: 교수 P5가 자료구조를 담당한다는 사실의 삽입을 하고 싶을 경우, 학번이 없으면 삽입 불가능
2. 삭제 이상: 100번 학생이 자료구조를 취소하여 투플을 삭제하면 P2가 담당 교수라는 사실도 함께 삭제
3. 갱신 이상: 교수 P1이 과목을 변경하게되면 P1 나타난 모든 투플을 변경해야함.
![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/ccf13c3a-fbad-4d58-a6ac-7ca7a3f41dc8)

이와 같이 정규화하면, 모든 결정자가 후보키가 되므로 보이스코드 정규형을 만족한다.

---

### 🌟제 4정규화(4NF)

함수종속이 아닌 다치종속을 제거하는 정규화

<aside>
💡 다치 종속: A→B일 때, 하나의 A값에 여러개의 B값이 존재하면 다치 종속이다. 최소 3개의 칼럼이 존재하게 된다.

</aside>

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/758fe2cd-c981-4df1-b6f9-23af5e82d31f)

불필요한 중복이 생기게 된다. 화일구조와 P1 이 불필요하게 중복되고, 교재가 다르다고 데이타베이스와 P3이 중복되게 써져야되고 이런일

---

### 🌟제 5정규화(5NF)

후보키를 통하지 않은 **조인종속**을 제거하는 정규화

함수적 종속성, 다치 종속성, 조인 종속성을 모두 고려하는 정규형으로, 프로젝트-조인 정규형이라고 한다. (PJNF)

조인 종속성을 발견하는 것은 매우 어려운 일로, 실제로 제 5정규형은 거의 쓰이지 않는다.

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/c1795b31-af0f-4065-b5e7-bb6c9e592df3)
