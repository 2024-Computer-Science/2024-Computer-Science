## Blocking I/O

<img src="https://grip.news/wp-content/uploads/2019/06/bio_01.gif">

### 진행 과정

1. 유저는 커널에게 read 작업을 요청하고 (제어권을 넘겨준다)

2. 데이터가 입력될 때까지 대기하다가 (제어권을 넘겨주었기 때문에 대기한다. 자기 작업을 제어할 수 없다.)

3. 데이터가 입력되면 유저에게 결과가 전달되어야만 유저 자신의 작업에 비로소 복귀할 수 있다. (제어권을 넘겨받는다.)

### 특징

- 가장 기본적인 I/O 모델

- Linux에서의 모든 소켓 통신은 기본 Blocking으로 동작한다.

- I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식이기 때문에 자원이 낭비된다. (I/O 작업이 CPU 자원을 거의 쓰지 않으므로)

- 여러 Client 가 접속하는 서버를 Blocking 방식으로 구현하는 경우 -> I/O 작업을 진행하는 작업을 중지 -> 다른 Client가 진행중인 작업을 중지하면 안되므로, client 별로 별도의 Thread를 생성해야 함 -> 접속자 수가 매우 많아짐 -> 많아진 Threads 로 컨텍스트 스위칭 횟수가 증가함,,, 비효율적인 동작 방식

<br>

## Non-Blocking I/O

<img src="https://velog.velcdn.com/images/bluecoolgod80/post/9e12e4ac-53c1-4d6e-bf13-baf4452c57f3/image.png">

### 진행 과정

1. 유저가 커널에게 read 작업을 요청한다.

2. 데이터 입력 유무에 관계없이, 결과가 바로 반환된다. (입력 데이터가 없다면 입력 데이터가 없다는 결과 메세지(EWOULDBLOCK)가 반환된다.)

3. 입력 데이터가 있을 때까지 1-2 과정을 반복한다. (제어권을 넘겨주지 않았기 때문에, 본인의 작업을 계속 수행할 수 있다.)

4. 입력 데이터가 있으면 유저에게 결과가 전달된다.

### 특징

- I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.

- I/O 작업 진행 시간과 관계 없기 때문에 application에서 작업을 오랜시간 중지하지 않고 I/O작업을 진행할 수 있다.

- 반복적으로 시스템 호출이 발생하기 때문에 자원이 낭비된다.
