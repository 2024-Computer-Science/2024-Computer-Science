# ⭐️ HTTP / HTTPS

## HTTP(HyperText Transfer Protocol)

**인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약**

애플리케이션 계층으로써, 웹 서비스 통신에 사용된다. HTTP/1.0부터 시작해 지금은 HTTP/3 에 해당한다.

**텍스트 교환**이므로, 누군가 네트워크에서 신호를 가로채가면 내용이 노출되는 보안적인 이슈가 발생할 수 있다.

### 보안 취약점

1. **도청 가능**
- 평문 (text)로 통신하므로 도청 가능
1. **위장 가능**
- 통신 상대를 확인하지 않음! 공격자와 소통할 수
1. **변조 가능**
- 완전성을 보장하지 않기 때문에, 변조가 가능하다.

이런 보안 문제를 해결해주는 프로토콜이 바로 **HTTPS** 이다.

---
### 🐍 HTTP/1.0

- 기본적으로 **한 연결당 하나의 요청** 처리 (요청 보낼때마다 핸드셰이크) → RTT 증가(패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간)
- 이를 해결하기 위해 **이미지 스플리팅, 코드 압축 ,이미지 Base64 인코딩** 사용
    - **이미지 스플리팅**: 많은 이미지가 합쳐 있는 하나의 이미지를 다운받고, background-image 의 position을 이용하여 이미지를 표기
    - **코드 압축**: 개행 문자, 빈칸을 없애서 코드의 크기를 최소화
    - **이미지 Base64 인코딩**: 이미지 파일을 64진법으로 이루어진 문자열로 인코딩. 이미지에 대해 서버와 연결을 열고 HTTP 요청을 할 필요가 없어지지만, 37%정도 크기가 더 커지는 단점이 있다.

---

### 🐍 HTTP/1.1

한번 TCP 초기화를 진행한 후, **keep-alive라는 옵션**으로 여러 개의 파일을 송수신할 수 있다. 한 번 핸드셰이크가 발생하면 그 담부턴 하지 않는다. 하지만 문서 안에 있는 다수의 리소스(이미지, css, script)를 처리하려면 요청할 리소스 개수에 비례하여 대기 시간이 길어진다.

**HOL Blocking** (Head Of Line blocking)

- 같은 큐에 있는 패킷이 그 첫 패킷에 의해 지연될 때 발생하는 성능 저하 현상.

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/09b8347d-1f75-4218-9cac-a964169961d3)


**무거운 헤더 구조**

- 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거움

---

### 🐍 HTTP/2

SPDY 프로토콜에서 파생된 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있는 프로토콜로, 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원한다. HTTPS 위에서 동작한다.

* **멀티플레싱**

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/99659f3a-ef70-4420-bf8b-06ff151916e8)

여러개의 **스트림**을 사용하여 송수신한다. **하나의 통로를 사용하긴 하지만 각기 다른 채널(스트림)을 이용** → 특정 스트림의 패킷이 손실되었다고 해도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡히 동작

```
💡 스트림: 실제 입력이나 출력이 표현된 데이터의 이상화된 흐름(가상 연결고리 같은 느낌)
```

이러면 단일 연결을 사용하여 병렬로 여러 요청을 받고 응답할 수 있다.

* **헤더 압축**

허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 통해 큰 헤더를 압축시킨다.

```
💡 허프만 코딩: 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를, 빈도가 낮은 정보는 많은 비트 수를 사용하여 표현하여 전체 데이터 표현에 필요한 비트양을 줄인다.
```

* **서버 푸시**

HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드받을 수 있지만, 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다.

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/53e39078-95ab-415c-aa54-a20e81b068bb)

--- 

### 🐍 HTTP/3

TCP위에서 돌아가는 HTTP/2와는 달리, HTTP/3은 **QUIC**이라는 계층 위에서 돌아가며 ,TCP기반이 아닌 **UDP 기반**으로 돌아간다.

멀티플렉싱을 가지고 있으며, 초기 연결 설정 시 지연 시간 감소라는 장점이 있다.

* **초기 연결 설정 시 지연 시간 감소**

  QUIC은 TCP를 사용하지 않고 **UDP를 기반**으로 하기 떄문에 **핸드셰이크가 필요 없다.** → RTT 감소. 첫 연결 설정에 1-RTT만 소요된다. 

* **순방향 오류 수정 메커니즘(FEC, Forword Error Correction)** 적용 : 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이고, 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑한다.

---

## ⭐️ HTTPS(HyperText Transfer Porotcol **Secure**)

**인터넷 상에서 정보를 암호화하는 `SSL 프로토콜`을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약**

SSL의 버전이 올라기면서 명칭이 바뀐게 TLS 라서 보통 SSL/TLS라고 한다. **전송 계층**에서 보안을 제공하는 프로토콜이다.

텍스트를 **암호화함** (공개키 암호화 방식)

1. 통신 자체를 암호화하여 도청 방지
2. CA 인증서를 통해 인증된 상대와 통신
3. 메세지 인증 코드(MAC), 전자 서명 등을 통해 변조 방지

---

🌊 ### 통신 흐름
```
💡 Certificate Authority(CA): 공개키를 저장해주는 신뢰성이 검증된 민간 기업
```

```
1. 서버🖤 를 만드는 기업 (A)는 HTTPS를 적용하기 위해 공개키와 개인키 생성
2. 신뢰할 수 있는 CA기관🕍 선택, 그 기관에게 내 공개키 관리를 부탁하며 계약
3. CA 기관🕍은 해당 기관의 이름, A서버🖤 의 공개키, 공개키 암호화 방법을 담은 인증서를 생성한다. 해당 인증서를 CA기관🕍 의 개인키로 암호화하여 A서버🖤 에게 제공
4. A서버🖤 는 암호화된 인증서를 받게 되어 A서버🖤 의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트🤍 에게 건네준다.
5. CA 기관🕍 의 공개키는 클라이언트🤍 가 이미 알고 있음! 왜냐면 신뢰할 수 있는 기업으로 등록되어 있기 때문에 브라우저가 인증서를 탐색하여 해독할 수 있다.
   따라서 해독하여 A서버🖤 의 공개키를 얻게된다.
6. 클라이언트🤍 가 A서버🖤 와 핸스쉐이킹 과정에서 주고받은 난수를 조합하여 pre-master-secret-key를 생성, A서버🖤 의 공개키로 해당 대칭키를 암호화하여 A서버🖤 로 보낸다.
7. A서버🖤 는 암호화된 대칭키를 자신의 개인키로 복호화하여 클라이언트와 동일한 대칭키를 획득한다.
8. 클라이언트🤍 , 서버🖤 는  pre master secret key를 master secret key로 만든다.
9. master secret key를 통해 session key를 생성하고, 이를 이용해 대칭키 방식으로 통신한다.
10. 각 통신이 종료될 때마다 session key를 파기한다.
```

무조건 안전한 것은 아니다!(신뢰 받는 CA기업이 아닌 자체 인증서 발급한 경우 등)

이때는 브라우저에서 주의 요함, 안전하지 않은 사이트 와 같은 알림으로 주의 받는다.
