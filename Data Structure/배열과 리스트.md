## 배열

메모리의 연속 공간에 값이 채워져있는 형태의 자료구조.

1. **인덱스**를 사용하여 값에 바로 접근할 수 있다. (O(1)만에 접근가능)
2. 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.
3. 배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 크기를 늘리거나 줄일 수 없다.
4. 지정된 크기가 초과되면 outOfIndexException 발생
5. 구조가 간단하므로 코딩 테스트에서 많이 이용한다.

### 성질

- O(1)에 k 번째 원소를 확인/변경 가능
- 추가적으로 소모되는 메모리의 양(오버헤드)가 거의없음
- 메모리상에 데이터들이 붙어있어서 cache hit rate(캐시 적중률)가 높음

<aside>
💡 원하는 정보가 캐시 메모리에 있을 때 적중(hit)되었다고 하고, 없으면 실패. 적중률 = 적중횟수/총 접근횟수 이고, 컴퓨터의 성능을 나타내는 척도로 사용.
적중률이 (0.95~-0.99 일 때 우수)

</aside>

- 메모리 상에 연속한 구간을 잡아야해서 할당에 제약이 있음

### 시간복잡도

O(1)

- 임의의 위치에 있는 원소를 확인/변경
- 끝에 있는 원소 삭제
- 원소를 끝에 추가

O(N)

- 임의의 위치에 원소를 추가 → 그 뒤 원소들을 한칸씩 밀어야함
- 임의의 위치에 있는 원소 제거 → 그 뒤 원소들을 한칸씩 땡겨야



## 리스트

값과 포인터를 묶은 **노드(NODE)** 라는 것을 포인터로 연결한 자료구조.

1. **인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야한다. 접근 속도가 느리다.**
2. 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산속도가 빠르다.
3. 선언할 때 **크기를 별도로 지정하지 않아도 된다.** 다시 말해 리스트의 크기는 정해져있지 않으며, 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
4. 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.

### 성질

- k번째 원소를 확인/변경하기 위해 O(k) 필요
- 임의의 위치에 원소를 추가/임의 위치의 원소 제거는 O(1)
- 원소들이 **메모리 상에 연속해있지 않아** 캐시적중률은 낮지만 할당이 쉬움
- 포인터를 저장할 공간이 필요하여 오버헤드가 발생

연결 리스트

- 단일 연결 리스트
- 이중 연결 리스트
- 원형 연결 리스트

### ArrayList vs LinkedList

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/626cead8-b135-4f9d-8128-24cc4cdd433a)

- arrayList는 index를 가지고 있고, LinkedList는 각 원소마다 앞, 뒤 원소의 위치값을 가지고 있다.

|  | ArrayList | LinkedList |
| --- | --- | --- |
| get() | O(1) | O(n) |
| head에 add()/remove() | O(n) | O(1) |
| tail에 add()/remove() | O(1) | late element의 위치를 알 때 - O(1)
모를 때O(n) |
| 중간에 add()/remove() | O(n) | serch time + O(1) |

add와 insert시에는 LinkedList의 성능이 좋고(특히 remove시), get 시에는 ArrayList의 성능이 좋다.

<aside>
💡 사실 실제로 성능면에서는 둘이 별 차이가 없다고 한다. 그냥 ArrayList를 많이 쓴다. 자바 LinkedList 구현한 개발자도 지가 만들었지만 잘 안쓴다한다. LinkedList가 Queue쓸 때 좋다하지만, 차라리 그런 경우에는 ArrayDeque라는 최적화된 컬렉션을 쓰는 게 더 좋다.

</aside>

### ArrayList

- 각 데이터의 index를 가지고 있어 **get이 유용**하다.
- 배열을 사용하면 크기가 지정되어있지만, ArrayList는크기를 정해주지 않아도 된다.
- 하지만 데이터 삽입 삭제 시,  맨앞에 2를 삭제했다면 나머지 뒤의 4개 인덱스를 아으로 하나씩 땡겨줘야하므로, 삽입과 삭제가 많다면 ArrayList는 비효율적이다.

### LinkedList

- 내부적으로 양방향 연결 리스트로 구성되어 있어, 참조하려는 원소에 따라 처음부터 정방향 또는 역순으로 순회가 가능하다.
- 순차적 접근이므로 데이터 검색 get이 느리다.
- **데이터 삽입-삭제 시** 가리키고 있는 주소값만 변경해주면 되기 때문에 **상당히 효율적이다.** 만약 위 그림에서 23 주소의 값을 삭제하면 head노드가  a주소를 가르키게만 하면 된다.
- listIterator를 사용할 수 있다.

### ListIterator

- LinkedList 클래스에 있는 요소를 순차접근하고 싶을 때, 효율적으로 접근할 수 있다.
- iterator가 없다면,  n개의 요소에 순차 접근하기 위해 매번 LinkedLIst.get(k)를 호출해야되고, 이의 시간복잡도는 O(n^2)의 시간이 된다.
- 최근의 접근했던 위치를 iterator가 기억하기 때문에, O(n)의 시간복잡도를 가질 수 있다.
