# HASH 해시
검색과 저장을 아주 빠르게 하는 자료구조.

key:value 형태로 구성. key는 중복이 불가능하다. key값이 배열의 인덱스로 저장되기에 검색과 저장이 빠르다.

### Hash Function & Hashing

key 를 고정된 길이의 hash로 변환

이 과정을 해싱이라고 한다.

key값을 해싱 과정을 통해 해시값, 해시코드로 변경하고, 이 해시 값이 저장 위치가 된다. 

해시 충돌을 줄이는 함수를 만드는게 중요하다.

### Hash Table

연관 배열 구조를 이용해 key:value로 저장하는 자료구조

해시 함수에 key를 적용해 나온 해시를 버킷 배열의 인덱스로하고 , 그자리에 value 저장

![image](https://github.com/user-attachments/assets/ec8a5781-961f-4e2a-b20a-629cfd5d61c9)

- 키,값이 주어졌을때, 그 두 값을 연관배열에 저장하는 명령 → put
- 키가 주어졌을 때, 연관 값을 얻는 명령 → get
- 키가 주어졌을 때, 그 키에 연관 값을 제거하는 명령 → remove

자바에서는 해시테이블의 구현체가 해시맵, 파이썬에서는 딕셔너리

### 주요 메서드

- put
- get
- remove
- keySet
- containsKey,containsValue
- size ..

### 장점

- 중복  제거
- 적은 자원으로 많은 데이터를 효율적으로 관리할 수 있다.
    - 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑할 경우 작은 메모리로도 프로세스 관리가 가능하다.
- 데이터 캐싱, 보안에 사용
- 배열의 인덱스로 접근하기에 삽입,삭제 등 연산이 빠르다.
- 언제나 동일한 해시값을 리턴하기에 index를 알면 빠른 데이터 검색이 가능하다.
- 해시테이블의 시간 복잡도는 O(1)

### 단점

- 공간 복잡도가 커진다.
- **충돌 발생** (충돌나면 O(1) → O(N))
- 순서가 있는 배열에는 어울리지 않음

### 충돌 해결 방식

chaining & open addressing(개방 주소법) & resize

### chaining → 버킷 내 linkedlist

연결리스트로 노드를 계속 추가해나갈 수 있다. but 메모리 문제는 발생할 수 있음

### open addressing → 다른 주소에 삽입

- 선형 탐색 → 다음 주소, 혹은 몇개 건너뛴 주소에 삽입 (정해진 고정폭)
- 제곱 탐색 → 제곱만큼 건너뛴 주소에 삽입
- 이중 해시 → 다른 해시를 한번 더 적용

![image](https://github.com/user-attachments/assets/a8d4464e-760c-46fa-95b7-0753c45b3bb0)

체이닝은 연결 리스트만 사용하면 되고, 계산식이 필요 없음. 해시테이블이 채워질수록 성능저하는 linear하게 발생

개방주소법은 포인터가 필요없고, 추가적인 저장공간도 필요없음. 삽입,삭제 시 오버헤드 적다. 저장할 데이터가 적을 때 유리

### 버킷 확장(resize)

해시 테이블 내 버킷 수가 일정 임계점에 도달하면 버킷을 늘려줘야된다. 일반적으로 75%가 찼을 때 버킷 수를 2배로 늘려준다.

다른 말로하면 load factor가 0.75 정도 됐다면 해시 버킷의 크기를 확장한다.


> 💡 load factor: 할당된 키의 개수 / 해시 버킷의 크기


해시 버킷이 동적 확장될때는 리해싱 과정을 거친다. 

- 기존 저장되어있는 값들을 다시 해싱하여 새로운 키 부여

( 여기서 주소 = 버킷 인 느낌)

### Question.

1. 데이터가 많아지면 해시는 충돌이 일어날 수 밖에 없는데 그럼에도 해시를 쓰는 이유는?
2. 충돌을 해결하는 방법에 대해 설명해보세요
