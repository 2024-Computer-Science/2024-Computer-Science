- 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 정렬하는 알고리즘
- 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요하다. (공간 복잡도가 높아진다.)
- 과정 (오름차순)
    1. 0~9 까지의 Bucket(Queue 자료구조)을 준비한다.
    2. 주어진 데이터의 숫자를 보고 1의 자리수의 숫자에 해당하는 Bucket에 데이터를 넣는다.
    3. Bucket 0부터 9까지 차례대로 데이터를 가져온다.
    4. 다음은 10의 자리수의 숫자에 해당하는 Bucket에 데이터를 넣는다.
    5. 역시 순서대로 데이터를 가져오면 정렬이 완료된다.
    
    
- 구현

```python
from collections import deque

def radix_sort(nums):
    # 0부터 9까지의 버킷을 만듭니다. 각 버킷은 deque로 구성됩니다.
    buckets = [deque() for _ in range(10)]

    # 배열에서 최대 값을 찾습니다.
    max_val = max(nums)
    
    # 초기 큐를 nums 배열로 설정합니다.
    Q = deque(nums)
    
    # 현재 자리수(1의 자리, 10의 자리, 100의 자리 등)를 나타내는 변수입니다.
    cur_ten = 1

    # 최대 자리수만큼 반복합니다.
    while max_val >= cur_ten:
        # 큐에 있는 모든 숫자를 올바른 버킷에 넣습니다.
        while Q:
            num = Q.popleft()  # 큐에서 숫자를 하나씩 뽑아냅니다.
            # 현재 자리수에 해당하는 숫자를 계산하여 해당 버킷에 넣습니다.
            buckets[(num // cur_ten) % 10].append(num)

        # 각 버킷에 있는 숫자들을 다시 큐에 넣습니다.
        for bucket in buckets:
            while bucket:
                Q.append(bucket.popleft())

        # 자리수를 10배 올립니다 (1의 자리 -> 10의 자리 -> 100의 자리 등).
        cur_ten *= 10

    # 정렬된 결과를 리스트로 반환합니다.
    return list(Q)

# 예제 배열을 정렬하여 출력합니다.
print(radix_sort([15, 27, 64, 25, 50, 17, 39, 28]))
```

- 시간 복잡도
    
    :  O(d * (n + b))
    
    - d는 최대값의 자릿수, b는 배열의 최댓값(기수 정렬의 경우에는 10으로 고정되어 있다.)
    
- 공간 복잡도
    
    : 기존에 주어진 배열에서 원소 Swap만 이루어지므로 공간 복잡도는 O(n)이다.
    

### 장점

1. 자릿수가 고정되어 있어서 안정성이 있다.
2. 문자열, 정수 정렬이 가능하다.

### 단점

1. 자릿수가 없는 것은 정렬할 수 없다. (부동 소숫점)
2. 중간 결과를 저장할 bucket 공간을 만들기 위한 메모리가 더 필요하다.
