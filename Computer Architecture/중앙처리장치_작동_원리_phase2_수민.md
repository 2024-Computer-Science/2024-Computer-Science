### 🌟 CPU의 구성 요소

💡 **산술 논리 연산 장치(ALU) : 산술 연산과 논리 연산을 수행한다.**

연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보낸다.

💡 **제어 장치(CU) : 명령어를 순서대로 실행할 수 있도록 제어하는 장치이다.**

RAM에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 **제어 신호**를 기억장치, 연산장치, 입출력장치로 보낸다. (이 과정에서 제어 버스를 이용한다.)

💡 **레지스터 : CPU 안에 있는 **고속 기억장치**로, 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장한다.**

CPU와 직접 연결되어있어서 메모리보다 연산 속도가 수십배~수백배 빠르다. CPU는 자체적으로 데이터를 저장할 방법이 없어서 레지스터를 거쳐서 데이터를 전달해야한다.

---

용도에 따라 범용 레지스터와 특수목적 레지스터로 구분된다.

중앙처리장치 종류에 따라 사용할 수 있는 레지스터 개수와 크기가 다르다.

* 범용 레지스터: 연산에 필요한 데이터나 연산 결과를 임시로 저장

* 특수목적 레지스터 : 특별 용도로 사용


    💡 주요 특수 목적 레지스터!
    
    **MAR(메모리 주소 레지스터)** : 읽기와 쓰기 연산을 수행할 주기억장치 주소를 저장
    
    **PC(프로그램 카운터)** : 다음에 수행할 명령어 주소 저장
    
    **IR(명령어 레지스터)** : 현재 실행 중인 명령어 저장
    
    **MBR(메모리 버퍼 레지스터)** : 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시 저장
    
    **AC(누산기)** : 연산 결과 임시 저장

</aside>

---

### 🌟 동작 과정

1. 주기억장치는 **입력 장치에서 받은 데이터** 또는 **보조기억장치에 저장된 프로그램**을 읽어온다.
2. CPU는 주 기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고, 다시 주기억장치에 저장한다.
3. 주기억장치는 처리 결과를 보조기억장치에 저장 or 출력장치로 보낸다.
4. 제어장치는 1~3과정에서 명령어가 순서대로 실행되도록 장치를 제어한다.

---

### 명령어세트

CPU가 실행할 명령어의 집합이다.

- 연산코드 + 피연산자로 이루어져 있는데, **연산 코드**는 실행할 연산, **피연산자**는 필요한 데이터 혹은 저장된 위치가 된다.
- 연산코드 : 연산, 제어, 데이터 전달, 입출력 기능
- 피연산자: 주소, 숫자/문자, 논리 데이터 ..

---

### 사이클

<aside>
💡 CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 '명령어 사이클'이라고 말한다.

</aside>

명령어 사이클은 

**인출/실행/간접/인터럽트 사이클**로 나누어진다.

주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, **실행 사이클에**서는 명령어를 실행한다. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 **인출 사이클**이 시작된다.

### 인출 사이클

> 인출 사이클에서 가장 중요한 부분은 **PC(프로그램 카운터) 값 증가**
> 


![image](https://github.com/user-attachments/assets/ff9a5f30-7252-40d4-ae09-dfd1642a6cd4)

- PC에 저장된 주소를 **MAR**로 전달
- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
- 인출한 명령어를 MBR에 저장
- 다음 명령어를 인출하기 위해 **PC 값 증가시킴**
- 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달

```
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

여기까지는 인출하기까지의 과정

---

### 실행 사이클

1. 데이터 처리: 데이터에 대한 산술 혹은 논리 연산 수행

> ADD addr 명령어 연산
> 

```
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

이미 인출이 진행되고 명령어만 실행하면 되기 때문에 PC를 증가할 필요없다.

IR에 MBR의 값이 이미 저장된 상태를 의미함

따라서 AC에 MBR을 더해주기만 하면 된다.

2.  데이터 이동: CPU와 기억장치/입출력 장치 간 이동

> LOAD addr 명령어 연산
> 

```
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← MBR
```

기억장치에 있는 데이터를 AC로 이동하는 명령어


3. 데이터의 저장: 연산 결과 데이터 혹은 입력장치로 부터 읽어 들인 데이터를 저장

> STA addr 명령어 연산
> 

```
T0 : MAR ← IR(Addr)
T1 : MBR ← AC
T2 : M[MAR] ← MBR
```

AC에 있는 데이터를 기억장치로 저장한다.

1. 프로그램 제어: 프로그램의 실행 순서를 결정

> JUMP addr 명령어 연산
> 

```
T0 : PC ← IR(Addr)

```

PC값을 IR의 주소값으로 변경하는 분기 명령어

---

### 간접 사이클

명령어의 operand(addr)가 간접 주소 지정방식인 경우, 유효주소를 계산하기 위해 메모리에 접근하는 단계

```java
T3 : MAR ← IR(addr)
T4 : MBR ← M[MAR]
T5 : IR(addr) <- MBR
```

---

### 인터럽트 사이클

CPU의 현재 처리 순서를 중단시키는 신호를 인터럽트라고 한다.

- 예외(exception): **CPU에 의해 발생**하는 인터럽트, CPU가 내부에서 명령어들을 수행하다가 예상치 못한 상황이 발생했을 때 발생하는 인터럽트
- 하드웨어 인터럽트(intterupt): 주로 입출력 등에서 알림처럼 **CPU 외부에서 처리할 예외 상황**이 발생할 때 발생하는 인터럽트

**인터럽트 서비스 루틴(ISR)**

인터럽트를 처리하기 위해 수행되는 프로그램 루틴

1. **현재 작업을 스택 영역에 백업한다.**
2. **인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신한다.**
3. **인터럽트 서비스 루틴을 실행한다.**
4. **스택에 저장해던 값을 불러온 후 원래 하던 작업을 마저 한다.**

```java
T0: MBR <- PC
T1: MAR <- SP, PC <- ISR의 시작주소
T2: M[MAR] <- MBR
```

1. PC내용을 MBR로 전송
2. 스택 포인터 SP의 내용을 MAR로 전송, PC는 ISR 시작 주소로 변경
3. MBR에 저장되어있던 원래 PC 내용을 스택에 저장

---

Q1. CPU의 구성요소에 대해 설명해보세요.

Q2. 중앙처리장치의 동작 과정을 설명해보세요.
