컴퓨터에서 실수를 표현하는 두 가지 방식 

## 고정 소수점 Fixed Point

정수를 표현하는 비트와 소수를 표현하는 비트수를 미리 고정하여 실수를 표현하는 방식

![image](https://github.com/user-attachments/assets/52293e58-8dd3-468c-a380-ab40d8fa2e45)

- 처음 **1비트**는 **sign(부호)**을 나타냅니다. 양수는 0, 음수는 1입니다.
- 다음 **15비트**는 **integer part(정수부)**를 나타냅니다.
- 다음 **16비트**는 **fractional part(소수부)**를 나타냅니다.
- 그리고 정수부와 소수부의 경계를 소수점의 위치라고 생각하고 2진수로 변환된 수를 그대로 넣으면 됩니다.
- 마지막으로 남는 자리는 모두 0으로 채우면 됩니다.

### **`예시`**

7.625를 32비트 고정 소수점으로 표현해보자.

7.625(10) = 111.101(2)

![image](https://github.com/user-attachments/assets/c33702cb-1c14-478c-bc62-35db2c2fd40e)

**장점** : 실수를 정수부와 소수부로 표현하여 단순하다.

**단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)

## 부동 소수점 Floating Point

소수점이 옮겨다니는 방식의 실수 표현법

![image](https://github.com/user-attachments/assets/8cdaff56-38e8-41a6-bec3-b89792210e52)

- 2진수를 **정규화(normalize)** 합니다.
- 처음 1비트는 **sign(부호)**를 나타냅니다 (0은 양수, 1은 음수).
- 다음 8비트는 **exponent(지수부)**를 나타냅니다. 정규화 과정에서 얻어낸 지수에 bias를 더한 값으로 채웁니다.
- 다음 23비트는 **mantissa(가수부)**를 나타냅니다. 소수 부분의 값으로 채웁니다.

> 지수 : 소수점의 위치를 가리키는 제곱승이 들어감.
> 

> 가수 : 실수의 실제값 표현
> 

### **`예시`**

7.625를 32비트 부동 소수점으로 표현해보자.

7.625(10) = 111.101(2)

정규화: 1.11101(2) x 2²

Exponent: 2(10) + 127(10)(bias) = 129(10) = 10000001(2)

Mantassia: 11101(2)

![image](https://github.com/user-attachments/assets/df20aea5-b9a5-4d69-9ebd-4a4d23246e14)

**장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)

**단점** : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)

## **결론**

- 고정 소수점은 주로 리소스가 제한적이고 높은 정밀도가 필요하지 않은 환경에서 사용됩니다.
- 부동 소수점은 더 넓은 범위와 높은 정밀도를 필요로 하는 복잡한 계산에 적합합니다.
- 현대 프로세서의 경우, 부동 소수점 연산의 속도도 매우 빨라져서 예전만큼 고정 소수점과 부동 소수점 사이의 성능 차이가 크지 않을 수 있습니다.
