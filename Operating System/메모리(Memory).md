### 메인 메모리(Main memory)

CPU가 직접 접근할 수 있는 기억장치이다.

프로세스가 실행되려면 프로그램이 메모리에 올라와 있어야 한다!

CPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져온다. 명령어 수행 시 **메모리에 필요한 데이터가 없으면** 해당 데이터를 우선 **메모리에 가져와야 된다.**

이 메모리에 가져오는 역할을 하는게 바로 MMU이다.

---

### ⭐️ MMU(Memory Management Unit, 메모리 관리 장치)

- 논리 주소를 물리 주소로 변환
- 메모리에 접근하는 것을 총 관리해주는 장치

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/60fec22f-abf7-4165-b2d3-688434c710f9)

메모리 공간이 한정적이므로, 사용자에게 더 많은 메모리를 제공하기 위해 ‘가상 주소’라는 개념이 등장한다.

이 가상 주소에서 실제 데이터가 담겨있는 곳에 접근하기 위해서는 빠른 주소 변환이 필요한데, 이를 MMU가 수행한다.

<aside>
💡 사용자가 메모리 주소를 일일이 할당하지 않아도되고, 프로세스 크기가 실제 메모리 용량을 초과해도 실행될 수 있다.

</aside>


또한 메인 메모리 직접 접근은 비효율적 이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재한다.

---

### ⭐️ MMU의 메모리 보호

프로세스는 독립적 메모리 공간을 가져야하고, 자신의 공간에만 접근해야한다.

하나의 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근일 경우 trap을 발생시켜 메모리를 보호한다.

![image](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/83461362/72771df2-d375-449d-83c0-e65c74bfe37a)

- base 레지스터:  메모리상의 프로세스 **시작 주소** 저장
- limit 레지스터: **프로세스의 사이즈**를 저장

<aside>
💡 `base ≤ x < base+limit` 주소 공간에만 접근이 가능하다.

</aside>

- 이 범위를 벗어날 경우 → trap 발생 (interrupt) → 커널에게 알린다.

안전성을 위해 base, limit레지스터는 **커널 모드**에서만 수정이 가능하다.

---

### ⭐️ 메모리 과할당(over allocating)

실제 메모리 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황을 말한다.

**→ 메모리에 남는 공간이 없는 상황**

페이지 기법과 같은 메모리 관리 기법은 **사용자가 눈치채지 못하도록** 가상 메모리로 메모리를 할당해준다.

근데 사용자가 눈치챌만한 상황이 존재하는데 그 상황이 어떤 상황이냐?

1. 프로세스 실행 도중 페이지 폴트가 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리의 빈 프레임에 페이지를 올려야 되는데 **모든 메모리가 사용중이라 빈 프레임이 없음**

이런 과할당을 해결하기 위해서는 Swapping기법을 활용해야한다.

- 프로세스를 일시적으로 메모리에서 쫒아내는 것.

<aside>
💡 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용

</aside>

---

### ⭐️ 페이지 교체

메모리 과할당이 발생했을 때, 프로세스 하나를 swap out하여 빈 프레임을 확보하는 것

1. 프로세스 실행 중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
    
    3-1. 있으면 해당 프레임 사용
    
    3-2. 없으면, **victim 프레임(메모리에서 내보내질 프레임)**을 선정해 디스크에 기록하고 페이지 테이블을 업데이트
    
    이 선정 과정에서 다양한 페이지 교체 알고리즘이 사용되는 것(FIFO, LRU ..)
    
4. 빈프레임에 페이지 폴트가 발생한 페이지 올리고, 페이지 테이블을 업데이트

페이지 교체가 이루어져도 사용자 입장에서는 아무일 없던 것처럼 프로세스를 계속 수행시켜줘야됨 → 페이지 교체 당시 오버헤드를 최대한 줄여줘야한다!

---

### ⭐️오버헤드 감소 방법

오버헤드는 페이지 교체가 많이 일어날수록 커진다. 

빈프레임이 없는 상황에서 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올릴 때 두번의 디스크 접근을 해야하고, 입출력 연산이 많이 발생하게 되며 오버헤드 문제가 발생

1. 변경비트를 모든 페이지마다 두어, victim 페이지가 정해지면 해당 페이지의 비트를 확인한다.

```c
if 비트 == set
	해당 페이지 내용이 디스크 상 페이지 내용과 달라졌다는 뜻
	페이지가 메모리에 올라온 이후 한 번이라도 수정이 일어났다! -> 디스크에 기록해야함
else if 비트 == clear
	디스크 상 페이지 내용과 메모리 상 페이지 내용이 일치
	디스크에 기록할 필요가 없다.
```

따라서 victim프레임을 비울 때 디스크에 기록을 안해도 될 때는 안해도 된다.

2. 페이지 교체 알고리즘을 잘 선택한다.
