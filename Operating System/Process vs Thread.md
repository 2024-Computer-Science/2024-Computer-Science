# Process vs Thread

## Process

- 컴퓨터에서 실행중인 프로그램을 의미
- 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 사용되기도 함

## 프로세스의 구성 요소

<img width="317" alt="Untitled" src="https://github.com/2024-Computer-Science/2024-Computer-Science/assets/21362256/39538fcb-21e9-4e94-95d0-4eb5b6033cce">



- 코드(Code) 영역
    - 프로그램 코드 자체
    - 프로그램 실행 시 주기억장치에 CPU가 해석할 수 있는 Binary Code 상태로 올라가게 되는데 이 때, 이 영역이 올라간다.
- 데이터(Data) 영역
    - 프로그램의 전역 변수(Global Variable)나 정적 변수(Static Variable)가 할당되는 영역
- 스택(Stack) 영역
    - 지역 변수(Local Variable)의 할당과 함수 호출 시 전달되는 인수(Argument)값을 저장하는 영역
- 힙(Heap) 영역
    - 동적 할당 시 활용되는 영역

## 멀티 프로세스

- 두 개 이상의 프로세서(CPU)가 협력을 통해 하나 이상의 작업(Task)을 동시에 처리하는 것 → 병렬 처리

### 장점

1. 독립된 구조로 안정성이 높다
2. 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다. (속도는 느려지지만, 프로세스가 정지되거나 죽지 않는다.)
3. 여러 개의 프로세스가 처리되어야 할 때 동일한 데이터를 공유하여 사용하면 비용적으로 저렴해진다.

### 단점

1. 독립된 메모리 영역이기 때문에, 작업량이 많을수록 Context Switcing이 자주 일어나서 오버헤드가 커진다. → 성능 저하 발생

<aside>
💡 Context Switching
현재 진행하고 있는 Task의 상태를 저장하고, 다음 진행할 Task의 상태 값을 읽어 적용하는 과정.

Context Switcing의 진행 과정
1. Task의 대부분의 정보는 Register에 저장되고, PCB(Proecess Control Block)으로 관리됨.
2. 현재 실행하고 있는 Task의 PCB정보를 저장 (Process Stack, Ready Queue를 사용)
3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고, CPU가 이전에 진행했던 과정을 연속적으로 수행

</aside>

---

## Thread

![Untitled 1](https://github.com/2024-Computer-Science/2024-Computer-Science/assets/21362256/d352afd7-ff6d-4f4c-bc28-68f83f5e7279)



- CPU에 작업 요청을 하는 실행 단위
- 운영체제입장에서의 작업 단위 → 프로세스
- CPU입장에서의 작업 단위 → 스레드

## 스레드의 구성 요소

- Thread ID
    - 각 스레드의 고유한 ID
- Program Counter(PC)
    - 다음에 실행할 명령어의 위치
- 레지스터 값
- 스택
    - 메서드 호출과 로컬 변수의 관리에서 사용.
    - 각 스레드는 독립적인 스택을 유지
    

## 멀티 스레드

- 여러 코어에서 한 번에 여러 개의 스레드를 처리하는 CPU 성능을 활용하는 프로그래밍 방식

### 장점

- 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다. → 다른 작업을 실행하는 도중에도 사용자와 상호작용 가능
- 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다. → 프로세스의 Context Switcing과는 다르게, 스레드 간의 Context Switcing은 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
- 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가한다 → 멀티 프로세서 활용

### 단점

- 둘 이상의 스레드가 동시에 실행하면 문제를 일으키는 코드블록(임계 영역, Critical Section)에 접근하는 경우 문제를 발생시킬 수 있다. → 동기화를 통해 해결
- 동기화 진행 시 Lock으로 인한 병목 현상을 발생시키 수 있다 → 성능 저하(뮤텍스와 세마포어 활용)
- Context Switcing, 동기화 등의 이유로 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 더 커져서 단일 스레드보다 오버헤드가 크다.

---

## 멀티 스레드 VS 멀티 프로세스

1. 메모리 공간 (멀티 스레드 < 멀티 프로세스)
    
    단, 동기화 문제 발생 시 하나의 스레드 장애가 전체 스레드 종료로 이어질 수 있다.
    
2. Context Switcing 오버헤드 (멀티 스레드 < 멀티 프로세스)

### 그럼 무조건 멀티스레드가 좋은가?

→ 자원의 효율성은 증가시킬 수 있지만, 스레드 간의 자원 공유는 전역 변수를 이용. 즉, 동기화 문제를 발생시킬 여지가 있어 프로그래머가 조심해서 사용해야 한다.
