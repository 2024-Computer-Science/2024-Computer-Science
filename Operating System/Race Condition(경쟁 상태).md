
# Race Condition
### 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

→ 동시 접근 시 자료의 일관성을 해칠 수 있음

### 해결방안 : **동기화**

- 쓰레드의 순차적 실행 보장

### 발생하는 경우

1. 싱글 코어에서 커널 작업 수행중 인터럽트 발생
    
    문제: 커널모드에서 데이터를 로드하여 작업 수행 중, 인터럽트가 발생하여 같은 데이터를 조작 할경우
    
    해결법: 작성 수행 중에는 인터럽트를 disable시켜 CPU 제어권을 가져가지 못하게 한다.
   
    
3. 프로세스의 System call으로 인해 커널모드로 진입하여 작업을 수행하는 도중 **문맥 교환**이 발생할 때
    
    문제: 프로세스1🐶이 커널모드에서 데이터를 조작하는 도중에 cpu허용 시간이 초과되어 제어권이 넘어가 프로세스2🐱가 같은 데이터를 조작하는 경우
    
    해결법: 프로세스가 커널모드에서 작업을 하는 동안에는 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 못하게한다.
    

    → 하지만 멀티 코어에서나, 스레드 여러개 사용 시 문맥교환이 일어나지 않게하는 것은 무용지물이 된다!

    →  2개의 코어에서 2개의 스레드를 갖고 접근한다면, 그냥 스레드의 접근 타이밍에 따라 결과가 망가짐(메모리를 공유)


3. 멀티 프로세서 환경에서 공유 메모리 내 커널 데이터에 접근할 때
    
    문제점: 2개의 CPU가 동시에 공유 데이터에 접근하여 조작하는 경우
    
    해결 : 커널 내부에 있는 공유데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock 설정

---

### Critical Section(임계 영역)

공유데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입하고 실행가능한 영역

임계 영역이 되려면 **3가지 조건**을 만족해야한다. 이를 만족하면 Lock을 사용할 수 있다.

1. **mutual exclusion(상호 배제)**: 임계영역에서는 하나의 스레드만 실행 가능
2. **progress(진행)**: 임계 영역이 비어있고, 임계 영역에 들어가고 싶은 스레드가 있다면, 실행할 수 있어야한다. 즉 임계영역에 있는 프로세스 외 다른 프로세스가 임계 영역에 진입하는 것을 방해하면 안된다. ( 진행이 계속되어야한다.)
3. **bounded wating(한정 대기)**: 임계 영역에 못들어간 스레드도 무한정 기다리면 안되고, 대기 시간을 한정해야한다. → 프로세스가 실행될 수 있는 상태임에도 자신의 차례가 오지 않는 기아 상태를 방지
    한 프로세스가 임계 영역에 진입하기를 요청한 순간부터, 그 프로세스를 제외한 나머지 프로세스들은 임계 영역에 진입할 수 있는 횟수가 한정된다. → 무조건 한정된 횟수안에 들어간다는 말

    ```
    1. A가 임계 영역에 진입 요청: 프로세스 A가 임계 영역에 진입을 요청한 시점부터 프로세스 B는 A가 진입할 때까지 최대 n번만 임계 영역에 진입할 수 있습니다.
    
    2. n번의 제한: 프로세스 A가 대기하는 동안 프로세스 B가 n번 임계 영역에 진입할 수 있지만, n번 이후에는 A에게 차례가 돌아가도록 보장됩니다.
    ```

출처: https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Race%20Condition.md
